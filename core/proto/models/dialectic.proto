syntax = "proto3";

option go_package = "epistemic-me-core/pb/models";

import "proto/models/beliefs.proto";
import "proto/models/source.proto";

// Add STATUS enum definition
enum STATUS {
    STATUS_INVALID = 0;
    PENDING_ANSWER = 1;
    ANSWERED = 2;
    BELIEFS_UPDATED = 3;
}

// Add InteractionType enum
enum InteractionType {
    INTERACTION_TYPE_INVALID = 0;
    QUESTION_ANSWER = 1;
    HYPOTHESIS_EVIDENCE = 2;
    ACTION_OUTCOME = 3;
}

// Add ActionType enum
enum ActionType {
    ACTION_TYPE_INVALID = 0;
    ANSWER_QUESTION = 1;
    COLLECT_EVIDENCE = 2;
    ACTUATE_OUTCOME = 3;
}

// A Question represents a request for information
// from a user. The intent behind a question is to extract
// beliefs from the end user in the form of an answer. 
// This data model may evolve in the future to track
// the origination of how the question is generated, 
// as well as a "dialectical context" of which beliefs 
// the agent is attempting to extract from the user. 
message Question {
    string question = 1;
    int64 created_at_millis_utc = 2;
}

// A User Answer is a response to a question that 
// may or may not contain an embedded belief, which can be
// extracted at a later point in time.
message UserAnswer {
    string user_answer = 1;
    int64 created_at_millis_utc = 2;
}

// Question-Answer interaction for extracting beliefs
message QuestionAnswerInteraction {
    Question question = 1;
    UserAnswer answer = 2;
    repeated Belief extracted_beliefs = 3;
    int64 updated_at_millis_utc = 4;
}

// Hypothesis-Evidence interaction for testing beliefs
message HypothesisEvidenceInteraction {
    string hypothesis = 1;
    string evidence = 2;
    bool is_counterfactual = 3;
    repeated Belief updated_beliefs = 4;
    int64 updated_at_millis_utc = 5;
}

// Action-Outcome interaction for testing causal beliefs
message ActionOutcomeInteraction {
    string action = 1;
    string outcome = 2;
    repeated Belief updated_beliefs = 3;
    int64 updated_at_millis_utc = 4;
}

// Update DialecticalInteraction to use the new types
message DialecticalInteraction {
    STATUS status = 1;
    InteractionType type = 2;
    string id = 3;
    
    // One of these based on type
    oneof interaction {
        QuestionAnswerInteraction question_answer = 4;
        HypothesisEvidenceInteraction hypothesis_evidence = 5;
        ActionOutcomeInteraction action_outcome = 6;
    }
    
    Observation predicted_observation = 7;
    Action action = 8;
    Observation observation = 9;
    Discrepancy discrepancy = 10;
    int64 updated_at_millis_utc = 11;
}

// The Dialectic Type informs the "strategy" of how the 
// agent will attempt to generate questions and interpret beliefs
// from the user's responses.
enum DialecticType {
    INVALID = 0;
    DEFAULT = 1;
    HEGELIAN = 2;
    SLEEP_DIET_EXERCISE = 3;
}

// The agent represents information about what underlying
// system or user is responsible for interacting with the
// user throughout the dialectic. This is intended to
// be some AI system (e.g., LLM) but may evolve to be a human
// user in the future.
message Agent {

    // Labels the system that is driving the agent's behavior.
    // This may include generating the question, synthesizing
    // the user's answers into beliefs, and then synthesizing
    // the user's supposed beliefs into a belief system
    // that can be used for further generations.
    enum AgentType {
        AGENT_TYPE_INVALID = 0;           // Invalid agent type.
        AGENT_TYPE_GPT_LATEST = 1;        // Latest GPT model.
        AGENT_TYPE_HUMAN = 2;             // A human user.
    }

    AgentType agent_type = 1;             // The type of the agent.
    DialecticType dialectic_type = 2;     // The dialectic strategy used by the agent.
}

// The dialectic can be seen as a session that gets created
// and presents a user with a series of questions designed to 
// determine and clarify the user's beliefs. The beliefs produced
// as part of the dialectic may or may not be fed into the user's
// underlying belief system. 
message Dialectic {
    string id = 1;                        // Unique identifier for the dialectic.
    // The user who the dialectic is "serving" in the sense
    // of who questions are being presented to and whose answers
    // represent the beliefs.
    string self_model_id = 2; 
    Agent agent = 3;                      // The agent conducting the dialectic.
    repeated DialecticalInteraction user_interactions = 4; // Interactions within the dialectic.
    BeliefSystem belief_system = 5; // Add this line
    BeliefAnalysis analysis = 6;  // Add this line
}

// Add a new message for the analysis
message BeliefAnalysis {
    float coherence = 1;
    float consistency = 2;
    float falsifiability = 3;
    float overall_score = 4;
    string feedback = 5;
    repeated string recommendations = 6;
    repeated string verified_beliefs = 7;
}

// Action represents a way to change the world state
message Action {
    ActionType type = 1;
    string dialectic_interaction_id = 2;  // Reference to the interaction
    string resource_id = 3;               // Reference to the resource used
    string intervention_id = 4;           // Optional reference to a defined intervention
    int64 timestamp = 5;
}

// Move ObservationType here from beliefs.proto
enum ObservationType {
    OBSERVATION_TYPE_INVALID = 0;
    ANSWER = 1;
    EVIDENCE = 2;
    OUTCOME = 3;
}

// Observation represents the observed state after an action
message Observation {
    string dialectic_interaction_id = 1;
    ObservationType type = 2;
    Source source = 3;
    map<string, float> state_distribution = 4;  // Maps state_id to probability
    int64 timestamp = 5;
}

// Update Discrepancy to remove observation_type
message Discrepancy {
    string dialectic_interaction_id = 1;  // Relationship to interaction
    double kl_divergence = 2;            // KL(P||Q) where P is predicted and Q is observed
    map<string, float> pointwise_kl_terms = 3;  // P(x) * log(P(x)/Q(x)) for each state
    int64 timestamp = 4;
}
